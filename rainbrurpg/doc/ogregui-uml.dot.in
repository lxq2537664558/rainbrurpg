/*
 *  Copyright 2006-2009 Jerome PASQUIER
 * 
 *  This file is part of RainbruRPG.
 *
 *  RainbruRPG is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  RainbruRPG is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with RainbruRPG; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 *  02110-1301  USA
 *
 */

include(rb_uml.m4)
// Process this file with m4 to produce a valid dot file
/*
  Trying to create a UML (Entity-Relation) diagram for OgreGUI

  XML escape sequences :
  &lt;     <
  &gt;     >
  &amp;    &
  &quot;   "
  &apos;   '
  &#35;	   #
  &#44;	   , (comma)

  &#123;   { Left curly brace
  &#125;   } Right curly brace

  UML attributes:
  + public attribute
  # protected attribute
  - private attribute

  virtual functions are in italic (see the graphviz fontfaq.txt file for advices):
    label=< <FONT FACE="DejaVu italic">serialize(Archive&amp;)</FONT> >

*/

digraph G {
  GRAPH_HEADER

// Classes definition
// Please keep this list sorted	
  implemented_class([Brush],
    members([[
      [- mAlpha: float]
    ]]),
    members([[
      [<FONT COLOR="red">Some stuff from QuadRenderer</FONT>],
      [+ setAlpha(vAlpha: float): void], 
      [+ getAlpha(): float]
    ]])
  )

  implemented_class([Container],
    members([[
      [mFocused: Focusable*], 
      [PROP([Receive key and mouse events.])]]
    ]),
    members([[
      [+ keyPressed(vEvent: const OIS::KeyEvent&amp;): void],
      [+ keyReleased(vEvent: const OIS::KeyEvent&amp;): void],
      [],
      [+ MouseMoved(vEvent: const OIS::MouseEvent&amp;): void],
      [+ MousePressed(vEvent: const OIS::MouseEvent&amp;, vButton: const OIS::MouseButtonID&amp;): void],
      [+ MouseReleased(vEvent: const OIS::MouseEvent&amp;, vButton: const OIS::MouseButtonID&amp;): void]
]])
  )

  implemented_class([Drawable],
    members([[
      [mRelativeX: int], [mRelativeY: int],
      [mWidth: int], [mHeight: int],
      [mAbsolute: Ogre::Rectangle],
      [mScissor: Ogre::Rectangle],
      [mSkinName: std::string],
      [mTexture: Ogre::TexturePtr ],
      [mParent: Drawable*],
      [mDirty=false: bool],
      [PROP([false by default to force the first computing])]
    ]]),
    members([[[Drawable(vParent: Drawable*,x: int, y: int, w: int, h: int, skin = "": const string&amp;)],
      [PROP([If skin is empty, take the parent skin name])],
      [ ],
      [+ inline isDirty(): bool],
      [+ setDirty(vDirty: bool): void],
      [PROP([To parent's propagation if vDirty is true])],
      [virtual([+ compute(vParentX: int, vParentY, int, vParentScissor: Rectangle) : void])],
      [PROP([Compute absolute position from relative one and scissor rectangle.])],
      [virtual([+ draw(vBrush: Brush*) : void])],
      [&#35; loadSkinnableTexture(vSkinName: string, vTextureName: string): void],
      [PROP([Call mTexture = loadTexture(vSkinName + "." + vTextureName).])],
      [&#35; loadTexture(vTextureName: string): TexturePtr],
      [&#35; computeAbsolute(vParentX: int, vParentY: int): void],
      [&#35; adjustScissor(vParentScissor: Ogre::Rectangle): void]
    ]])
  )

  implemented_class([Focusable],
    members([[
      [- mCanTakeFocus: bool], 
      [- mFocus: bool ]]
    ]),
    members([[
      [virtual([+ keyPressed(vEvent: const OIS::KeyEvent&amp;): bool])],
      [PROP([All these event-related functions return true if event is consummed.])],
      [virtual([+ keyReleased(vEvent: const OIS::KeyEvent&amp;): bool])],
      [],
      [virtual([+ MouseMoved(vEvent: const OIS::MouseEvent&amp;): bool])],
      [virtual([+ MousePressed(vEvent: const OIS::MouseEvent&amp;, vButton: const OIS::MouseButtonID&amp;): bool])],
      [virtual([+ MouseReleased(vEvent: const OIS::MouseEvent&amp;, vButton: const OIS::MouseButtonID&amp;): bool])],
      [ ],
      [+ setFocus(vFocus: bool)]
]])
  )

  class([FreeWindow],
    members([[[- mScrollPane: ScrollPane]]]),
    members([[[virtual([+ add(int, int, int, int, Widget*): void])]]]),
    [: public Layout &lt;int, int&gt;]
  )
  note([FreeWindow],[
The add(...) implementation of<BR/>
FreeWindow add the widget to the<BR/>
instancied ScrollPane instead of<BR/>
the Layout.
])

  class([GameEngine],
    members([[
      [- mStates: std::vector&lt;GameState*&gt;],
      [- mActualState: int],
      [PROP([mStates[mActualState] receive all key and mouse events.])],
      [- mbrush: Brush],
      [- mGuiTransparency: float]]]),
    members([[[+ draw() : void],
      [PROP([Call draw() on actual gamestate with mBrush])],
      [+ setGuiTransparency(vTransparency: float): void],
      [PROP([Use Brush::setAlpha() for each frame.])],
      [ - getGuiTransparency(): float]
    ]]))

  class([GameState],
    members([[[- mContainer: Container],
      [PROP([Receive all Key and mouse events])]]]),
      [- mFocusedWidget]
    members([[[+ draw(Brush*) : void],
      [PROP([Call compute(0,0) if dirty then draw() on mContainer])]
    ]]))

  note([GameState], [
Should reimplement key handling<BR/>
from Serializable to handle TAB<BR/>
key for keyboard navigation using<BR/>
WidgetList::focusNext() and<BR/> 
WidgetList::focusPrevious().
  ])

  class([Layout],
    members([[[- mList: std::list&lt;LayoutObject&lt;T1&#44; T2&gt;]]]),
    members([[
      [virtual(+ add(T1, T1, T2, T2, Widget*): void)],
      [&#35; computeAll(vAbsolute: Ogre::Rectangle): void ],
      [PROP([Call compute() for all widgets with filled arguments.])],
      [virtual([&#35; compute(T1, T1, T2, T2, Widget*)=0: void])],
      [PROP([Purely virtual. Must be reimplented in sub-classes.])],
      [virtual([&#35; addCheck(T1, T1, T2, T2, Widget*)=0])],
      [PROP([Called by add(). Return true if widget is added to the list.])],
      
    ]]),
    [&lt;T1, T2&gt;]
  )

  class([LayoutObject],
    members([[
      [- T1 mX = 0],     [- T1 mY = 0],
      [- T2 mWidth = 0], [- T2 mHeight = 0],
      [- Widget* mWidget = NULL]
    ]]),
    members([[
      [+ LayoutObject(T1, T1, T2, T2, Widget*)], 
      [virtual([+ ~LayoutObject()])],
      [ ],
      [+ getX() const: T1],
      [+ getY() const: T1],
      [+ getWidth() const: T2],
      [+ getHeight() const: T2],
      [+ getWidget() const: Widget*],
      [ ],
      [+ setX(const T1&amp;): void],
      [+ setY(const T1&amp;): void],
      [+ setWidth(const T2&amp;): void],
      [+ setHeight(const T2&amp;): void],
      [+ setWidget(Widget*): void]
    ]]),
    [&lt;T1, T2&gt;]
  )

  class([MultiColumnList],
    members([[[ ], [ ]]]),
    members([[[ ], [ ]]])
  )

  class([MultiColumnListContent],
    members([[[ ], [ ]]]),
    members([[[ ], [ ]]])
  )

  class([MultiColumnListHeader],
    members([[[ ], [ ]]]),
    members([[[ ], [ ]]])
  )

  class([MultiColumnListRow],
    members([[[ ], [ ]]]),
    members([[[ ], [ ]]])
  )

  class([PopupMenu],
    members([[[ ], [ ]]]),
    members([[[ ], [ ]]])
  )

  class([ScrollPane],
    members([[[ ], [ ]]]),
    members([[[ ], [ ]]])
  )

  implemented_class([Serializable],
    members([[
      [- mName: string], 
      [- mUniqueName: string]
    ]]),
    members([[
      [virtual([+ setUniqueName(vParentUniqueName: const string&amp;): void])], 
      [PROP([mUniqueName = vParentUniqueName + "/" + type + englishName])],
      [+ getUniqueName(): const string&amp;], 
      [virtual([+ serialize(Archive&amp;): void])], 
      [virtual([+ deserialize(Archive&amp;): void])]
    ]])
  )

  implemented_class([Widget],
    members([[[ ], [ ]]]),
    members([[[ ], [ ]]])
  )
  note([Widget], [
Widget should have a constructor without <BR/>
position and size. Not needed because <BR/>
Layout::compute(...) can modify these values.
  ])

  implemented_class([WidgetList],
    members([[[ ], [ ]]]),
    members([[
      [virtual([+ setUniqueName(vParentUniqueName: const string&amp;): void])], 
      [PROP([Set unique name of all children])],
      [+ focusNext(void): Focusable*],
      [PROP([Returns NULL if end of list])],
      [+ focusPrevious(void): Focusable*],
      [PROP([Returns NULL if end of list])]
    ]])
  )
  note([WidgetList], [
Must be based on a STL container<BR/>
that support reverse iterator.
  ])

  class([Window],
    members([[
      [<FONT COLOR="red">Should implement events and  skins</FONT>], 
      [PROP([Should set SkinName to "default"])]
    ]]),
    members([[[ ], [ ]]])
  )
     

// Here start the hierarchy formalism
  relation(  [Drawable],     [Widget])
  relation_m([Focusable],    [[Widget], [GameState], [GameEngine]])
  relation_m([Serializable], [[Widget], [WidgetList]])
  relation_m([Widget],       [[Window], [Container]])
  relation([WidgetList],     [Container])
  relation_m([Container],    [
    [PopupMenu],
    [ScrollPane],
    [MultiColumnListHeader],
    [MultiColumnListRow]
  ])
  relation_m([ScrollPane], [[MultiColumnList], [MultiColumnListContent]])
  relation([Window], [FreeWindow])
  relation([Layout], [FreeWindow])

// Here start the instanciation formalism (no arrow and numerical attributes
     edge [[
       arrowhead = "none"
       arrowtail = "none"
     ]]	   
     edge[[
       headlabel = "      0..*"
       taillabel = ""
     ]]
     LayoutObject -> Layout

     edge[[
       headlabel = "1"
       taillabel = ""
     ]]
     ScrollPane -> FreeWindow

}
