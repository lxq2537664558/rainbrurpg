/* system-dependent definitions for RainbruRPG

   Written for GNU fileutils.
   Adapted for autoproject by James R. Van Zandt.

   Copyright (C) 89, 91, 92, 93, 94, 1996 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/** \file
  *
  * System-dependent definitions
  *
  * This file was generated by autoproject. please see 
  * http://directory.fsf.org/project/autoproject/ for further informations.
  *
  * Modifications :
  * - 17 jul 2008 : Doxygen documentation
  *
  */

#if HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */

/* Include sys/types.h before this file.  */

#include <sys/stat.h>

#ifdef STAT_MACROS_BROKEN
#undef S_ISBLK
#undef S_ISCHR
#undef S_ISDIR
#undef S_ISFIFO
#undef S_ISLNK
#undef S_ISMPB
#undef S_ISMPC
#undef S_ISNWK
#undef S_ISREG
#undef S_ISSOCK
#endif /* STAT_MACROS_BROKEN.  */

#ifndef S_IFMT
/** These bits determine file type.  
  *
  * This define can be found in \c sys/stat.h or bits/stat.h (named  
  * \c __S_IFMT).
  *
  */
#define S_IFMT 0170000
#endif
#if !defined(S_ISBLK) && defined(S_IFBLK)
#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#endif
#if !defined(S_ISCHR) && defined(S_IFCHR)
#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISDIR) && defined(S_IFDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG) && defined(S_IFREG)
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISFIFO) && defined(S_IFIFO)
#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISLNK) && defined(S_IFLNK)
#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK) && defined(S_IFSOCK)
#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISMPB) && defined(S_IFMPB) /* V7 */
#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
#endif
#if !defined(S_ISNWK) && defined(S_IFNWK) /* HP/UX */
#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
#endif

#ifndef S_IEXEC
/** Semmes to be an alias for \ref S_IXUSR
  *
  * The signification could be `execute by owner`.
  *
  */
#define S_IEXEC S_IXUSR
#endif

#ifndef S_IXUSR
/** A protection bit telling if the file can be execute by owner
  *
  * The \c S_IXUSR macro is defined in \c sys/stat.h as an alias for
  * the \c __S_IXUSR one, defined in \c bits/stat.h
  *
  */
#define S_IXUSR S_IEXEC
#endif
#ifndef S_IXGRP
/** A protection bit telling if the file can be execute by group
  *
  * This macro can be already declared in \c sys/stat.h.
  *
  */
#define S_IXGRP (S_IEXEC >> 3)
#endif
#ifndef S_IXOTH
/** A protection bit telling if the file can be execute by others
  *
  * This macro can be already declared in \c sys/stat.h.
  *
  */
#define S_IXOTH (S_IEXEC >> 6)
#endif
#ifndef S_IXUGO
/** A protection bit telling if the file is executable by everyone
  *
  * I can't find another declaration of this macro anywhere, so
  * I think it's executable by owner (\ref S_IXUSR), group (\ref S_IXGRP) 
  * and other (\ref S_IXOTH) : everyone.
  *
  */
#define S_IXUGO (S_IXUSR | S_IXGRP | S_IXOTH)
#endif

#if !defined(HAVE_MKFIFO)
/** Creats a new FIFO
  *
  * \param path The name of the new FIFO
  * \param mode The permission bits for the new FIFO
  *
  */
#define mkfifo(path, mode) (mknod ((path), (mode) | S_IFIFO, 0))
#endif

#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

/* <unistd.h> should be included before any preprocessor test
   of _POSIX_VERSION.  */
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifndef STDIN_FILENO
/** The standard input file descriptor */
#define STDIN_FILENO 0
#endif

#ifndef STDOUT_FILENO
/** The standard output file descriptor */
#define STDOUT_FILENO 1
#endif

#ifndef STDERR_FILENO
/** The standard error output file descriptor */
#define STDERR_FILENO 2
#endif

/* FIXME: Don't use _POSIX_VERSION.  */
#ifndef _POSIX_VERSION
/** Move the read/write file offset
  *
  */
off_t lseek ();
#endif

#ifdef TM_IN_SYS_TIME
#include <sys/time.h>
#else
#include <time.h>
#endif

/* Since major is a function on SVR4, we can't use `ifndef major'.  */
#ifdef MAJOR_IN_MKDEV
#include <sys/mkdev.h>
#define HAVE_MAJOR
#endif
#ifdef MAJOR_IN_SYSMACROS
#include <sys/sysmacros.h>
#define HAVE_MAJOR
#endif
#ifdef major			/* Might be defined in sys/types.h.  */
#define HAVE_MAJOR
#endif

#ifndef HAVE_MAJOR
/** A macro to access dev_t values 
  *
  * \c dev_t represent file device numbers. The major number defines the 
  * driver used to controle the device.
  *
  */
#define major(dev)  (((dev) >> 8) & 0xff)
/** A macro to access dev_t values 
  *
  * \c dev_t represent file device numbers. The minor number defines the 
  * (unique) device:
  *
  * \todo More documentation needed 
  *
  */
#define minor(dev)  ((dev) & 0xff)
/** A macro to access dev_t values 
  *
  * \c dev_t represent file device numbers. This macro create a dev_t
  * from a major and minor versions
  *
  * \sa \ref major(), \ref minor()
  *
  */
#define makedev(maj, min)  (((maj) << 8) | (min))
#endif
#undef HAVE_MAJOR

#ifdef HAVE_UTIME_H
#include <utime.h>
#endif

/* Some systems (even some that do have <utime.h>) don't declare this
   structure anywhere.  */
#ifndef HAVE_STRUCT_UTIMBUF
/** Defines access and modification times for a file
  *
  */
struct utimbuf
{
  long actime;   //!< Access time
  long modtime;  //!< Modification time
};
#endif

/* Don't use bcopy!  Use memmove if source and destination may overlap,
   memcpy otherwise.  */

#ifdef HAVE_STRING_H
# if !STDC_HEADERS && HAVE_MEMORY_H
#  include <memory.h>
# endif
# include <string.h>
#else
# include <strings.h>
/** Search in the memory
  *
  * This function should be defined in <string.h> header.
  *
  */
char *memchr ();
#endif

#include <errno.h>
#ifndef errno
/** Error return value
  *
  * Returns the code of the last error.
  *
  */
extern int errno;
#endif

#ifdef STDC_HEADERS
#define getopt system_getopt
#include <stdlib.h>
#undef getopt
#else /* not STDC_HEADERS */

/** Get environment string
  *
  * Retrieves a C string containing the value of the environment variable 
  * whose name is specified as argument. If the requested variable is not 
  * part of the environment list, the function returns a NULL pointer.
  *
  */
char *getenv ();
#endif /* STDC_HEADERS */

/* The following test is to work around the gross typo in
   systems like Sony NEWS-OS Release 4.0C, whereby EXIT_FAILURE
   is defined to 0, not 1.  */
#if !EXIT_FAILURE
# undef EXIT_FAILURE
/** Define an exit value for program failure
  *
  * With this define, you can call \c exit(EXIT_FAILURE).
  *
  */
# define EXIT_FAILURE 1
#endif

#ifndef EXIT_SUCCESS
/** Define an exit value for program success
  *
  * With this define, you can call \c exit(EXIT_SUCCESS).
  *
  */
# define EXIT_SUCCESS 0
#endif

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#else
#include <sys/file.h>
#endif

#ifndef SEEK_SET
/** Seek from beginning of file.
  * 
  * A possibilitie for the third argument to `fseek', a function defined
  * in \c stdio.h that sets the position indicator associated with a stream 
  * to a new position defined by adding an offset to a reference position 
  * specified by origin. This value can be used as origin.
  *
  */
#define SEEK_SET 0
/** Seek from current position.
  * 
  * A possibilitie for the third argument to `fseek', a function defined
  * in \c stdio.h that sets the position indicator associated with a stream 
  * to a new position defined by adding an offset to a reference position 
  * specified by origin. This value can be used as origin.
  *
  */
#define SEEK_CUR 1
/** Seek from end of file.
  * 
  * A possibilitie for the third argument to `fseek', a function defined
  * in \c stdio.h that sets the position indicator associated with a stream 
  * to a new position defined by adding an offset to a reference position 
  * specified by origin. This value can be used as origin.
  *
  */
#define SEEK_END 2
#endif
#ifndef F_OK

/** Test for existence
  *
  * Value for the second argument of the access() function (defined in 
  * \c unistd.h. It may be OR'd with other ?_OK macros.   
  *
  */
#define F_OK 0

/** Test for execute permission
  *
  * Value for the second argument of the access() function (defined in 
  * \c unistd.h. It may be OR'd with other ?_OK macros.   
  *
  */
#define X_OK 1

/** Test for write permission
  *
  * Value for the second argument of the access() function (defined in 
  * \c unistd.h. It may be OR'd with other ?_OK macros.   
  *
  */
#define W_OK 2

/** Test for read permission
  *
  * Value for the second argument of the access() function (defined in 
  * \c unistd.h. It may be OR'd with other ?_OK macros.   
  *
  */
#define R_OK 4
#endif

#ifdef HAVE_DIRENT_H
# include <dirent.h>
# define NLENGTH(direct) (strlen((direct)->d_name))
#else /* not HAVE_DIRENT_H */
/** Fake dirent definition if dirent.h not found
  *
  * This macro is used to fake dirent in the \ref NLENGTH() one.
  *
  * Please check http://www.delorie.com/gnu/docs/autoconf/autoconf_50.html
  * for more informations
  *
  */
# define dirent direct
/** Get the length of a directory name
  *
  * Please check http://www.delorie.com/gnu/docs/autoconf/autoconf_50.html
  * for more informations
  *
  */
# define NLENGTH(direct) ((direct)->d_namlen)
# ifdef HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif /* HAVE_SYS_NDIR_H */
# ifdef HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif /* HAVE_SYS_DIR_H */
# ifdef HAVE_NDIR_H
#  include <ndir.h>
# endif /* HAVE_NDIR_H */
#endif /* HAVE_DIRENT_H */

#ifdef CLOSEDIR_VOID
/** Fake a return value if closedir() return void. 
  *
  * The real closedir function is declared in \c dirent.h. The \c CLOSEDIR_VOID
  * macro is defined by automake if the \c C_FUNC_CLOSEDIR_VOID automake 
  * check function find that dirent.h closedir() function return void.
  *
  */
#define CLOSEDIR(d) (closedir (d), 0)
#else
/** Fake a return value if closedir() return void.  
  *
  * The real closedir function is declared in \c dirent.h. The \c CLOSEDIR_VOID
  * macro is defined by automake if the \c C_FUNC_CLOSEDIR_VOID automake 
  * check function find that dirent.h closedir() function return void.
  *
  */
#define CLOSEDIR(d) closedir (d)
#endif

/* Get or fake the disk device blocksize.
   Usually defined by sys/param.h (if at all).  */
#ifndef DEV_BSIZE
#ifdef BSIZE
#define DEV_BSIZE BSIZE
#else /* !BSIZE */
/** Define a fake block size if it can be get from sys/param.h
  *
  * The \c DEV_BSIZE macro should be defined in \c sys/param.h but if
  * not, we fake it with a standard value.
  *
  * \sa \ref ST_BLKSIZE
  *
  */
#define DEV_BSIZE 4096
#endif /* !BSIZE */
#endif /* !DEV_BSIZE */

/* Extract or fake data from a `struct stat'.
   ST_BLKSIZE: Optimal I/O blocksize for the file, in bytes.
   ST_NBLOCKS: Number of 512-byte blocks in the file
   (including indirect blocks). */
#ifndef HAVE_ST_BLOCKS
/** Get the block size from a stat struct
  *
  * The stat structure is defined in \c bits/stat.h and a call to this macro
  * should return \c stat.st_blksize, but if \c HAVE_ST_BLOCKS si not defined,
  * automake cannot find \c st_blksize in \c stat, we fake it and return
  * the \ref DEV_BSIZE value.
  *
  * \sa \ref DEV_BSIZE
  *
  */
# define ST_BLKSIZE(statbuf) DEV_BSIZE
# if defined(_POSIX_SOURCE) || !defined(BSIZE) /* fileblocks.c uses BSIZE.  */
/** Define a way to get the block size */
#  define ST_NBLOCKS(statbuf) (((statbuf).st_size + 512 - 1) / 512)
# else /* !_POSIX_SOURCE && BSIZE */
/** Define a way to get the block size */
#  define ST_NBLOCKS(statbuf) (st_blocks ((statbuf).st_size))
# endif /* !_POSIX_SOURCE && BSIZE */
#else /* HAVE_ST_BLOCKS */
/** Some systems, like Sequents, return st_blksize of 0 on pipes. */
# define ST_BLKSIZE(statbuf) ((statbuf).st_blksize > 0 \
			       ? (statbuf).st_blksize : DEV_BSIZE)
# if defined(hpux) || defined(__hpux__) || defined(__hpux)
/** HP-UX hack for block count
  *
  * HP-UX counts st_blocks in 1024-byte units. This loses when mixing 
  * HP-UX and BSD filesystems with NFS. 
  *
  */
#  define ST_NBLOCKS(statbuf) ((statbuf).st_blocks * 2)
# else /* !hpux */
#  if defined(_AIX) && defined(_I386)
/* AIX PS/2 counts st_blocks in 4K units.  */
#   define ST_NBLOCKS(statbuf) ((statbuf).st_blocks * 8)
#  else /* not AIX PS/2 */
#   if defined(_CRAY)
#    define ST_NBLOCKS(statbuf) ((statbuf).st_blocks * ST_BLKSIZE(statbuf)/512)
#   else /* not AIX PS/2 nor CRAY */
#    define ST_NBLOCKS(statbuf) ((statbuf).st_blocks)
#   endif /* not _CRAY */
#  endif /* not AIX PS/2 */
# endif /* !hpux */
#endif /* HAVE_ST_BLOCKS */

/** Convert B 512-byte blocks to kilobytes if K is nonzero,
  * otherwise return it unchanged. 
  *
  */
#define convert_blocks(b, k) ((k) ? ((b) + 1) / 2 : (b))

#ifndef RETSIGTYPE
/** The return type for signals declarations  */
#define RETSIGTYPE void
#endif

#ifdef __GNUC__
# undef alloca
# define alloca __builtin_alloca
#else
# ifdef HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifndef _AIX
/* AIX alloca decl has to be the first thing in the file, bletch! */

/** Allocate space in the stack frame 
  *
  * The \c alloca() function allocates space in the stack frame of the 
  * caller, and returns a pointer to the allocated block. This temporary 
  * space is automatically freed when the function from which \c alloca() 
  * is called returns.
  *
  */
char *alloca ();
#  endif
# endif
#endif

#include <ctype.h>

/* Jim Meyering writes:

   "... Some ctype macros are valid only for character codes that
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   using /bin/cc or gcc but without giving an ansi option).  So, all
   ctype uses should be through macros like ISPRINT...  If
   STDC_HEADERS is defined, then autoconf has verified that the ctype
   macros don't need to be guarded with references to isascii. ...
   Defining isascii to 1 should let any compiler worth its salt
   eliminate the && through constant folding."

   Bruno Haible adds:

   "... Furthermore, isupper(c) etc. have an undefined result if c is
   outside the range -1 <= c <= 255. One is tempted to write isupper(c)
   with c being of type `char', but this is wrong if c is an 8-bit
   character >= 128 which gets sign-extended to a negative value.
   The macro ISUPPER protects against this as well."  */

#if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
/** Hacking for some systems
  *
  * On some system, ctype only valid for ASCII character, to be able to
  * use isupper(c) etc. with out-of-range values (-1 <= c <= 255 is the correct
  * range), we hack.
  * 
  * When defined to, the given character is always ASCII.
  *
  * \sa \ref ISBLANK
  *
  */
#define IN_CTYPE_DOMAIN(c) 1
#else
#define IN_CTYPE_DOMAIN(c) isascii(c)
#endif

#ifdef isblank
#define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
#else
/** Defines a macro that test if a character is blank
  *
  * The \ref IN_CTYPE_DOMAIN is used here in some system to know if the 
  * character is ascii.
  *
  * \param c The char to test
  *
  */
#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
#endif
#ifdef isgraph
#define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
#else
/** Is the given char a graphic one
  *
  * Tells if the char is printable and non-space.
  *
  * \param c The char to test
  *
  */
#define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !isspace (c))
#endif

/** Tests for a printable character
  *
  * The \c isprint() function is defined in \c <ctype.h>, it shall test whether 
  * \c c is a character of class print in the program's current locale; 
  *
  * The c argument is an int, the value of which the application shall 
  * ensure is a character representable as an unsigned char or equal to 
  * the value of the macro EOF. If the argument has any other value, the 
  * behavior is undefined.
  *
  * \param c The character to test
  *
  * \return The isprint() function shall return non-zero if c is a 
  *         printable character; otherwise, it shall return 0.
  *
  */
#define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))

/** Test for an alphanumeric character
  *
  * The \c isalnum() function is defined in \c <ctype.h>, it shall test 
  * whether \c c is a character of class alpha or digit in the program's 
  * current locale.
  *
  * The c argument is an int, the value of which the application shall 
  * ensure is representable as an unsigned char or equal to the value 
  * of the macro EOF. If the argument has any other value, the behavior 
  * is undefined.
  *
  * \param c The character to test
  *
  * \return The isalnum() function shall return non-zero if c is an 
  *         alphanumeric character; otherwise, it shall return 0.
  *
  */
#define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))

/** test for an alphabetic character
  *
  * The \c isalnumpha() function is defined in \c <ctype.h>, it shall test 
  * whether c is a character of class alpha in the program's current locale.
  *
  * The \c c argument is an int, the value of which the application shall 
  * ensure is representable as an unsigned char or equal to the value 
  * of the macro EOF. If the argument has any other value, the behavior 
  * is undefined.
  *
  * \param c The character to test
  *
  * \return The \c isalpha() function shall return non-zero if c is an 
  *         alphabetic character; otherwise, it shall return 0.
  *
  */
#define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))

/** Test for a control character
  *
  * The \c iscntrl() function is defined in \c <ctype.h>, it shall test 
  * whether c is a character of class cntrl in the program's current locale.
  *
  * The c argument is a type int, the value of which the application shall 
  * ensure is a character representable as an unsigned char or equal to 
  * the value of the macro EOF. If the argument has any other value, the 
  * behavior is undefined.
  *
  * \param c The character to test
  *
  * \return The \c iscntrl() function shall return non-zero if c is a 
  *         control character; otherwise, it shall return 0.
  *
  */
#define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))

/** Test for a lowercase letter
  *
  * The \c islower() function is defined in \c <ctype.h>, it shall test 
  * whether c is a character of class lower in the program's current locale.
  *
  * The c argument is an int, the value of which the application shall 
  * ensure is a character representable as an unsigned char or equal to 
  * the value of the macro EOF. If the argument has any other value, the 
  * behavior is undefined.
  *
  * \param c The character to test
  *
  * \return The \c islower() function shall return non-zero if c is a 
  *         control character; otherwise, it shall return 0.
  *
  */
#define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))

/** Test for a punctuation character
  *
  * The \c ispunct() function is defined in \c <ctype.h>, it shall test 
  * whether c is a character of class punct in the program's current locale.
  *
  * The c argument is an int, the value of which the application shall 
  * ensure is a character representable as an unsigned char or equal to 
  * the value of the macro EOF. If the argument has any other value, 
  * the behavior is undefined.
  *
  * \param c The character to test
  *
  * \return The \c ispunct() function shall return non-zero if c is a 
  *         control character; otherwise, it shall return 0.
  *
  */
#define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))

/** Test for a white-space character
  *
  * The \c isspace() function is defined in \c <ctype.h>, it shall test whether 
  * \c c is a character of class space in the program's current locale.
  *
  * The c argument is an int, the value of which the application shall 
  * ensure is a character representable as an unsigned char or equal to 
  * the value of the macro EOF. If the argument has any other value, the 
  * behavior is undefined.
  *
  * \param c The character to test
  *
  * \return The \c isspace() function shall return non-zero if c is a 
  *         white-space character; otherwise, it shall return 0.
  *
  */
#define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))

/** Test for an uppercase letter
  *
  * The \c isupper() function is defined in \c <ctype.h>, it shall test 
  * whether \c c is a character of class upper in the program's current 
  * locale.
  *
  * The \c c argument is an int, the value of which the application shall 
  * ensure is a character representable as an unsigned char or equal to 
  * the value of the macro EOF. If the argument has any other value, 
  * the behavior is undefined.
  *
  * \param c The character to test
  *
  * \return The \c isupper() function shall return non-zero if c is a 
  *         uppercase letter; otherwise, it shall return 0.
  *
  */
#define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))

/** Test for a hexadecimal digit
  *
  * The \c isxdigit() function is defined in \c <ctype.h>, it shall test 
  * whether c is a character of class xdigit in the program's current 
  * locale.
  *
  * The c argument is an int, the value of which the application shall 
  * ensure is a character representable as an unsigned char or equal 
  * to the value of the macro EOF. If the argument has any other value, 
  * the behavior is undefined.
  *
  * \param c The character to test
  *
  * \return The \c isxdigit() function shall return non-zero if c is a 
  *         hexadecimal digit; otherwise, it shall return 0.
  *
  */
#define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))

/** Test for a decimal digit
  *
  * The \c isdigit() function is defined in \c <ctype.h>, it shall test 
  * whether c is a character of class digit in the program's current 
  * locale.
  *
  * The c argument is an int, the value of which the application shall 
  * ensure is a character representable as an unsigned char or equal 
  * to the value of the macro EOF. If the argument has any other value, 
  * the behavior is undefined.
  *
  * \param c The character to test
  *
  * \return The \c isdigit() function shall return non-zero if c is a 
  *         decimal digit; otherwise, it shall return 0.
  *
  */
#define ISDIGIT_LOCALE(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))

/** Test for a decimal digit
  *
  * ISDIGIT differs from ISDIGIT_LOCALE, as follows:
  * - Its arg may be any int or unsigned int; it need not be an unsigned char.
  * - It's guaranteed to evaluate its argument exactly once.
  * - It's typically faster.
  * Posix 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
  * only '0' through '9' are digits.  Prefer ISDIGIT to ISDIGIT_LOCALE unless
  * it's important to use the locale's definition of `digit' even when the
  * host does not conform to Posix.  
  *
  */
#define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)

#ifndef __P
#if defined (__GNUC__) || (defined (__STDC__) && __STDC__)

/** Provides extra type-checking provided by prototypes
  *
  * Is is a macro used in function declaration to makes differences
  * between new compilers and old ones.
  *
  */
#define __P(args) args
#else
/** Provides extra type-checking provided by prototypes
  *
  * Is is a macro used in function declaration to makes differences
  * between new compilers and old ones.
  *
  */
#define __P(args) ()
#endif  /* GCC.  */
#endif  /* Not __P.  */

/* Take care of NLS matters.  */

#if HAVE_LOCALE_H
# include <locale.h>
#endif
#if !HAVE_SETLOCALE
/** Deactivate gettext setlocale macro
  *
  * This function, declared in \c <locale.h>  is used to set the
  * localization of the program.
  *
  * \param Category One of the following : LC_ALL, LC_COLLATE, LC_CTYPE, 
  *                 LC_MONETARY, LC_NUMERIC, LC_TIME (Please see GNU gettext 
  *                 documentation).
  *
  * \param Locale   The locale to set (ex. \c fr_FR, \c en_US ...)
  *
  *
  * \sa \ref bindtextdomain(), \ref  textdomain()
  */
# define setlocale(Category, Locale) /* empty */
#endif

#if ENABLE_NLS
# include <libintl.h>
# define _(Text) gettext (Text)
#else
# undef bindtextdomain
/** \def bindtextdomain
  * Sets the base directory of the hierarchy containing message catalogs 
  * for a given message domain.
  *
  * \param Domain must be a non-empty string.
  *
  * \param Directory If dirname is not NULL, the base directory for 
  *        message catalogs belonging  to  domain domainname is set to dirname.
  *
  * \return NULL on error
  *
  */
# define bindtextdomain(Domain, Directory) /* empty */
# undef textdomain
/** Set domain for future gettext() calls 
  *
  */
# define textdomain(Domain) /* empty */
/** A macro use instead of gettext()
  *
  * \param Text The translatable string
  *
  */
# define _(Text) Text
#endif

/** Test for equality of strings
  *
  * This macro uses strcmp().
  *
  * \param a,b The string to compare
  *
  */
#define STREQ(a,b) (strcmp((a), (b)) == 0)
